#!/usr/bin/perl -w
# dgit
# Integration between git and Debian-style archives
#
# Copyright (C)2013 Ian Jackson
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;

use IO::Handle;
use Data::Dumper;
use LWP::UserAgent;
use Dpkg::Control::Hash;
use File::Path;
use Dpkg::Version;
use POSIX;

our $suite = 'sid';
our $package;

our $sign = 1;
our $dryrun = 0;
our $changesfile;
our $new_package = 0;
our $existing_package = 'dpkg';

our %format_ok = map { $_=>1 } ("1.0","3.0 (native)","3.0 (quilt)");

our (@git) = qw(git);
our (@dget) = qw(dget);
our (@dput) = qw(dput);
our (@debsign) = qw(debsign);
our $keyid;

our $debug = 0;
open DEBUG, ">/dev/null" or die $!;

our %opts_opt_map = ('dget' => \@dget,
		     'dput' => \@dput,
		     'debsign' => \@debsign);

our $remotename = 'dgit';
our $ourdscfield = 'Vcs-Dgit-Master';
our $branchprefix = 'dgit';

sub lbranch () { return "$branchprefix/$suite"; }
my $lbranch_re = '^refs/heads/'.$branchprefix.'/([^/.]+)$';
sub lref () { return "refs/heads/".lbranch(); }
sub lrref () { return "refs/remotes/$remotename/$suite"; }
sub rrref () { return "refs/$branchprefix/$suite"; }
sub debiantag ($) { return "debian/$_[0]"; }

sub fetchspec () {
    local $suite = '*';
    return  "+".rrref().":".lrref();
}

our $ua;

sub url_get {
    if (!$ua) {
	$ua = LWP::UserAgent->new();
	$ua->env_proxy;
    }
    print "downloading @_...\n";
    my $r = $ua->get(@_) or die $!;
    die "$_[0]: ".$r->status_line."; failed.\n" unless $r->is_success;
    return $r->decoded_content();
}

our ($dscdata,$dscurl,$dsc);

sub printcmd {
    my $fh = shift @_;
    my $intro = shift @_;
    print $fh $intro or die $!;
    local $_;
    foreach my $a (@_) {
	$_ = $a;
	if (s{['\\]}{\\$&}g || m{\s} || m{[^-_./0-9a-z]}i) {
	    print $fh " '$_'" or die $!;
	} else {
	    print $fh " $_" or die $!;
	}
    }
    print $fh "\n" or die $!;
}

sub runcmd {
    printcmd(\*DEBUG,"+",@_) if $debug>0;
    $!=0; $?=0;
    die "@_ $! $?" if system @_;
}

sub printdone {
    if (!$dryrun) {
	print "dgit ok: @_\n";
    } else {
	print "would be ok: @_ (but dry run only)\n";
    }
}

sub cmdoutput_errok {
    die Dumper(\@_)." ?" if grep { !defined } @_;
    printcmd(\*DEBUG,"|",@_) if $debug>0;
    open P, "-|", @_ or die $!;
    my $d;
    $!=0; $?=0;
    { local $/ = undef; $d = <P>; }
    die if P->error;
    if (!close P) { print DEBUG "=>!$?\n" if $debug>0; return undef; }
    chomp $d;
    $d =~ m/^.*/;
    print DEBUG "=> \`$&'",(length $' ? '...' : ''),"\n" if $debug>0; #';
    return $d;
}

sub cmdoutput {
    my $d = cmdoutput_errok @_;
    defined $d or die "@_ $? $!";
    return $d;
}

sub dryrun_report {
    printcmd(\*STDOUT,"#",@_);
}

sub runcmd_ordryrun {
    if (!$dryrun) {
	runcmd @_;
    } else {
	dryrun_report @_;
    }
}

our %defcfg = ('dgit.default.distro' => 'debian',
	       'dgit.default.username' => '',
	       'dgit.default.archive-query-default-component' => 'main',
	       'dgit.default.ssh' => 'ssh',
	       'dgit-distro.debian.git-host' => 'git.debian.org',
	       'dgit-distro.debian.git-proto' => 'git+ssh://',
	       'dgit-distro.debian.git-path' => '/git/dgit-repos',
	       'dgit-distro.debian.git-check' => 'ssh-cmd',
	       'dgit-distro.debian.git-create' => 'ssh-cmd',
	       'dgit-distro.debian.mirror' => 'http://http.debian.net/debian/');

sub cfg {
    foreach my $c (@_) {
	my $v;
	{
	    local ($debug) = $debug-1;
	    $v = cmdoutput_errok(@git, qw(config --), $c);
	};
	if ($?==0) {
	    return $v;
	} elsif ($?!=256) {
	    die "$c $?";
	}
	my $dv = $defcfg{$c};
	return $dv if defined $dv;
    }
    return undef;
}

sub access_distro () {
    return cfg("dgit-suite.$suite.distro",
	       "dgit.default.distro");
}

sub access_cfg ($) {
    my ($key) = @_;
    my $distro = access_distro();
    my $value = cfg("dgit-distro.$distro.$key",
		    "dgit.default.$key");
    return $value;
}

sub access_gituserhost () {
    my $user = access_cfg('git-user');
    my $host = access_cfg('git-host');
    return defined($user) && length($user) ? "$user\@$host" : $host;
}

sub access_giturl () {
    my $url = access_cfg('git-url');
    if (!defined $url) {
	$url =
	    access_cfg('git-proto').
	    access_gituserhost().
	    access_cfg('git-path');
    }
    return "$url/$package.git";
}	       

sub parsecontrol {
    my $c = Dpkg::Control::Hash->new();
    $c->load(@_) or return undef;
    return $c;
}

sub parsechangelog {
    my $c = Dpkg::Control::Hash->new();
    my $p = new IO::Handle;
    open $p, '-|', qw(dpkg-parsechangelog) or die $!;
    $c->parse($p);
    $?=0; $!=0; close $p or die "$! $?";
    return $c;
}

our %rmad;

sub archive_query () {
    my $query = access_cfg('archive-query');
    $query ||= "madison:".access_distro();
    $query =~ s/^(\w+):// or die "$query ?";
    my $proto = $1;
    my $url = $'; #';
    die unless $proto eq 'madison';
    $rmad{$package} ||= cmdoutput
	qw(rmadison -asource),"-s$suite","-u$url",$package;
    my $rmad = $rmad{$package};
    if (!length $rmad) {
	return ();
    }
    $rmad =~ m{^ \s*( [^ \t|]+ )\s* \|
                 \s*( [^ \t|]+ )\s* \|
                 \s*( [^ \t|/]+ )(?:/([^ \t|/]+))? \s* \|
                 \s*( [^ \t|]+ )\s* }x or die "$rmad $?";
    $1 eq $package or die "$rmad $package ?";
    my $vsn = $2;
    if ($suite ne $3) {
	# madison canonicalises for us
	print "canonical suite name for $suite is $3\n";
	$suite = $3;
    }
    my $component;
    if (defined $4) {
	$component = $4;
    } else {
	$component = access_cfg('archive-query-default-component');
    }
    $5 eq 'source' or die "$rmad ?";
    my $prefix = substr($package, 0, $package =~ m/^l/ ? 4 : 1);
    my $subpath = "/pool/$component/$prefix/$package/${package}_$vsn.dsc";
    return ($vsn,$subpath);
}

sub canonicalise_suite () {
    archive_query() or die;
}

sub get_archive_dsc () {
    my ($vsn,$subpath) = archive_query();
    if (!defined $vsn) { $dsc=undef; return undef; }
    $dscurl = access_cfg('mirror').$subpath;
    $dscdata = url_get($dscurl);
    my $dscfh = new IO::File \$dscdata, '<' or die $!;
    print DEBUG Dumper($dscdata) if $debug>1;
    $dsc = Dpkg::Control::Hash->new(allow_pgp=>1);
    $dsc->parse($dscfh, 'dsc') or die "parsing of $dscurl failed\n";
    print DEBUG Dumper($dsc) if $debug>1;
    my $fmt = $dsc->{Format};
    die "unsupported format $fmt, sorry\n" unless $format_ok{$fmt};
}

sub check_for_git () {
    # returns 0 or 1
    my $how = access_cfg('git-check');
    if ($how eq 'ssh-cmd') {
	my $r= cmdoutput
	    (access_cfg('ssh'),access_gituserhost(),
	     " set -e; cd ".access_cfg('git-path').";".
	     " if test -d $package.git; then echo 1; else echo 0; fi");
	die "$r $! $?" unless $r =~ m/^[01]$/;
	return $r+0;
    } else {
	die "unknown git-check $how ?";
    }
}

sub create_remote_git_repo () {
    my $how = access_cfg('git-create');
    if ($how eq 'ssh-cmd') {
	runcmd_ordryrun
	    (access_cfg('ssh'),access_gituserhost(),
	     "set -e; cd ".access_cfg('git-path').";".
	     " mkdir -p $package.git;".
	     " cd $package.git;".
	     " if ! test -d objects; then git init --bare; fi");
    } else {
	die "unknown git-create $how ?";
    }
}

our ($dsc_hash,$upload_hash);

our $ud = '.git/dgit/unpack';

sub prep_ud () {
    rmtree($ud);
    mkpath '.git/dgit';
    mkdir $ud or die $!;
}

sub mktree_in_ud_from_only_subdir () {
    # changes into the subdir
    my (@dirs) = <*/.>;
    die unless @dirs==1;
    $dirs[0] =~ m#^([^/]+)/\.$# or die;
    my $dir = $1;
    chdir $dir or die "$dir $!";
    die if stat '.git';
    die $! unless $!==&ENOENT;
    runcmd qw(git init -q);
    rmtree('.git/objects');
    symlink '../../../../objects','.git/objects' or die $!;
    runcmd @git, qw(add -Af);
    my $tree = cmdoutput @git, qw(write-tree);
    $tree =~ m/^\w+$/ or die "$tree ?";
    return ($tree,$dir);
}

sub dsc_files () {
    map {
	m/^\w+ \d+ (\S+)$/ or die "$_ ?";
	$1;
    } grep m/\S/, split /\n/, ($dsc->{'Checksums-Sha256'} || $dsc->{Files});
}

sub is_orig_file ($) {
    local ($_) = @_;
    m/\.orig(?:-\w+)?\.tar\.\w+$/;
}

sub make_commit ($) {
    my ($file) = @_;
    return cmdoutput @git, qw(hash-object -w -t commit), $file;
}

sub generate_commit_from_dsc () {
    prep_ud();
    chdir $ud or die $!;
    my @files;
    foreach my $f (dsc_files()) {
	die if $f =~ m#/|^\.|\.dsc$|\.tmp$#;
	push @files, $f;
	link "../../../$f", $f
	    or $!==&ENOENT
	    or die "$f $!";
    }
    runcmd @dget, qw(--), $dscurl;
    foreach my $f (grep { is_orig_file($_) } @files) {
	link $f, "../../../../$f"
	    or $!==&EEXIST
	    or die "$f $!";
    }
    my ($tree,$dir) = mktree_in_ud_from_only_subdir();
    runcmd qw(sh -ec), 'dpkg-parsechangelog >../changelog.tmp';
    my $clogp = parsecontrol('../changelog.tmp','changelog') or die;
    my $date = cmdoutput qw(date), '+%s %z', qw(-d),$clogp->{Date};
    my $author = $clogp->{Maintainer};
    $author =~ s#,.*##ms;
    my $authline = "$author $date";
    $authline =~ m/^[^<>]+ \<\S+\> \d+ [-+]\d+$/ or die $authline;
    open C, ">../commit.tmp" or die $!;
    print C <<END or die $!;
tree $tree
author $authline
committer $authline

$clogp->{Changes}

# imported from the archive
END
    close C or die $!;
    my $outputhash = make_commit qw(../commit.tmp);
    print "synthesised git commit from .dsc $clogp->{Version}\n";
    if ($upload_hash) {
	runcmd @git, qw(reset --hard), $upload_hash;
	runcmd qw(sh -ec), 'dpkg-parsechangelog >>../changelogold.tmp';
	my $oldclogp = Dpkg::Control::Hash->new();
	$oldclogp->load('../changelogold.tmp','previous changelog') or die;
	my $vcmp =
	    version_compare_string($oldclogp->{Version}, $clogp->{Version});
	if ($vcmp < 0) {
	    # git upload/ is earlier vsn than archive, use archive
	    open C, ">../commit2.tmp" or die $!;
	    print C <<END or die $!;
tree $tree
parent $upload_hash
parent $outputhash
author $authline
committer $authline

Record $package ($clogp->{Version}) in archive suite $suite
END
            $outputhash = make_commit qw(../commit2.tmp);
	} elsif ($vcmp > 0) {
	    print STDERR <<END or die $!;
Version actually in archive:    $clogp->{Version} (older)
Last allegedly pushed/uploaded: $oldclogp->{Version} (newer or same)
Perhaps the upload is stuck in incoming.  Using the version from git.
END
            $outputhash = $upload_hash;
	} elsif ($outputhash ne $upload_hash) {
	    die "version in archive ($clogp->{Version})".
		" is same as version in git".
		" to-be-uploaded (upload/) branch ($oldclogp->{Version})".
		" but archive version hash no commit hash?!\n";
        }
    }
    chdir '../../../..' or die $!;
    runcmd @git, qw(update-ref -m),"dgit fetch import $clogp->{Version}",
            'DGIT_ARCHIVE', $outputhash;
    cmdoutput @git, qw(log -n2), $outputhash;
    # ... gives git a chance to complain if our commit is malformed
    rmtree($ud);
    return $outputhash;
}

sub ensure_we_have_orig () {
    foreach my $f (dsc_files()) {
	next unless is_orig_file($f);
	if (stat "../$f") {
	    die "$f ?" unless -f _;
	} else {
	    die "$f $!" unless $!==&ENOENT;
	}
	my $origurl = $dscurl;
	$origurl =~ s{/[^/]+$}{};
	$origurl .= "/$f";
	die "$f ?" unless $f =~ m/^${package}_/;
	die "$f ?" if $f =~ m#/#;
	runcmd_ordryrun qw(sh -ec),'cd ..; exec "$@"','x',
	    @dget,'--',$origurl;
    }
}

sub rev_parse ($) {
    return cmdoutput @git, qw(rev-parse), "$_[0]~0";
}

sub is_fast_fwd ($$) {
    my ($ancestor,$child) = @_;
    my $mb = cmdoutput @git, qw(merge-base), $ancestor, $child;
    return rev_parse($mb) eq rev_parse($ancestor);
}

sub git_fetch_us () {
    die "cannot dry run with fetch" if $dryrun;
    runcmd @git, qw(fetch),access_giturl(),fetchspec();
}

sub fetch_from_archive () {
    # ensures that lrref() is what is actually in the archive,
    #  one way or another
    get_archive_dsc() or return 0;
    $dsc_hash = $dsc->{$ourdscfield};
    if (defined $dsc_hash) {
	$dsc_hash =~ m/\w+/ or die "$dsc_hash $?";
	$dsc_hash = $&;
	print "last upload to archive specified git hash\n";
    } else {
	print "last upload to archive has NO git hash\n";
    }

    my $lrref_fn = ".git/".lrref();
    if (open H, $lrref_fn) {
	$upload_hash = <H>;
	chomp $upload_hash;
	die "$lrref_fn $upload_hash ?" unless $upload_hash =~ m/^\w+$/;
    } elsif ($! == &ENOENT) {
	$upload_hash = '';
    } else {
	die "$lrref_fn $!";
    }
    print DEBUG "last upload hash $upload_hash\n";
    my $hash;
    if (defined $dsc_hash) {
	die "missing git history even though dsc has hash"
	    unless $upload_hash;
	$hash = $dsc_hash;
	ensure_we_have_orig();
    } else {
	$hash = generate_commit_from_dsc();
    }
    print DEBUG "current hash $hash\n";
    if ($upload_hash) {
	die "not fast forward on last upload branch!".
	    " (archive's version left in DGIT_ARCHIVE)"
	    unless is_fast_fwd($upload_hash, $hash);
    }
    if ($upload_hash ne $hash) {
	my @upd_cmd = (@git, qw(update-ref -m), 'dgit fetch', lrref(), $hash);
	if (!$dryrun) {
	    cmdoutput @upd_cmd;
	} else {
	    dryrun_report @upd_cmd;
	}
    }
    return 1;
}

sub clone ($) {
    my ($dstdir) = @_;
    die "dry run makes no sense with clone" if $dryrun;
    mkdir $dstdir or die "$dstdir $!";
    chdir "$dstdir" or die "$dstdir $!";
    runcmd @git, qw(init -q);
    runcmd @git, qw(config), "remote.$remotename.fetch", fetchspec();
    open H, "> .git/HEAD" or die $!;
    print H "ref: ".lref()."\n" or die $!;
    close H or die $!;
    runcmd @git, qw(remote add), 'origin', access_giturl();
    if (check_for_git()) {
	print "fetching existing git history\n";
	git_fetch_us();
	runcmd @git, qw(fetch origin);
    } else {
	print "starting new git history\n";
    }
    fetch_from_archive() or die;
    runcmd @git, qw(reset --hard), lrref();
    printdone "ready for work in $dstdir";
}

sub fetch () {
    if (check_for_git()) {
	git_fetch_us();
    }
    fetch_from_archive() or die;
    printdone "fetched into ".lrref();
}

sub pull () {
    fetch();
    runcmd_ordryrun @git, qw(merge -m),"Merge from $suite [dgit]",
        lrref();
    print "dgit ok: fetched to ".lrref()." and merged into HEAD\n";
}

sub dopush () {
    runcmd @git, qw(diff --quiet HEAD);
    my $clogp = parsechangelog();
    $package = $clogp->{Source};
    my $dscfn = "${package}_$clogp->{Version}.dsc";
    stat "../$dscfn" or die "$dscfn $!";
    $dsc = parsecontrol("../$dscfn");
    prep_ud();
    chdir $ud or die $!;
    print "checking that $dscfn corresponds to HEAD\n";
    runcmd qw(dpkg-source -x --), "../../../../$dscfn";
    my ($tree,$dir) = mktree_in_ud_from_only_subdir();
    chdir '../../../..' or die $!;
    runcmd @git, qw(diff --exit-code), $tree;
#fetch from alioth
#do fast forward check and maybe fake merge
#    if (!is_fast_fwd(mainbranch
#    runcmd @git, qw(fetch -p ), "$alioth_git/$package.git",
#        map { lref($_).":".rref($_) }
#        (uploadbranch());
    $dsc->{$ourdscfield} = rev_parse('HEAD');
    $dsc->save("../$dscfn.tmp") or die $!;
    if (!$dryrun) {
	rename "../$dscfn.tmp","../$dscfn" or die "$dscfn $!";
    } else {
	print "[new .dsc left in $dscfn.tmp]\n";
    }
    if (!$changesfile) {
	my $pat = "../${package}_$clogp->{Version}_*.changes";
	my @cs = glob $pat;
        die "$pat ?" unless @cs==1;
	($changesfile) = @cs;
    }
    my $tag = debiantag($dsc->{Version});
    if (!check_for_git()) {
	create_remote_git_repo();
    }
    runcmd_ordryrun @git, qw(push),access_giturl(),"HEAD:".rrref();
    if ($sign) {
	my @tag_cmd = (@git, qw(tag -s -m),
		       "Release $dsc->{Version} for $suite [dgit]");
	push @tag_cmd, qw(-u),$keyid if defined $keyid;
	push @tag_cmd, $tag;
	runcmd_ordryrun @tag_cmd;
	my @debsign_cmd = @debsign;
	push @debsign_cmd, "-k$keyid" if defined $keyid;
	push @debsign_cmd, $changesfile;
	runcmd_ordryrun @debsign_cmd;
    }
    runcmd_ordryrun @git, qw(push),access_giturl(),"refs/tags/$tag";
    my $host = access_cfg('upload-host');
    my @hostarg = defined($host) ? ($host,) : ();
    runcmd_ordryrun @dput, @hostarg, $changesfile;
    printdone "pushed and uploaded $dsc->{Version}";
}

sub cmd_clone {
    parseopts();
    my $dstdir;
    die if defined $package;
    if (@ARGV==1) {
	($package) = @ARGV;
    } elsif (@ARGV==2 && $ARGV[1] =~ m#^\w#) {
	($package,$suite) = @ARGV;
    } elsif (@ARGV==2 && $ARGV[1] =~ m#^[./]#) {
	($package,$dstdir) = @ARGV;
    } elsif (@ARGV==3) {
	($package,$suite,$dstdir) = @ARGV;
    } else {
	die;
    }
    $dstdir ||= "$package";
    clone($dstdir);
}

sub branchsuite () {
    my $branch = cmdoutput_errok @git, qw(symbolic-ref HEAD);
    if ($branch =~ m#$lbranch_re#o) {
	return $1;
    } else {
	return undef;
    }
}

sub fetchpullargs () {
    if (!defined $package) {
	my $sourcep = parsecontrol('debian/control');
	$package = $sourcep->{Source};
    }
    if (@ARGV==0) {
	$suite = branchsuite();
	if (!$suite) {
	    my $clogp = parsechangelog();
	    $suite = $clogp->{Distribution};
	}
	canonicalise_suite();
	print "fetching from suite $suite\n";
    } elsif (@ARGV==1) {
	($suite) = @ARGV;
	canonicalise_suite();
    } else {
	die;
    }
}

sub cmd_fetch {
    parseopts();
    fetchpullargs();
    fetch();
}

sub cmd_pull {
    parseopts();
    fetchpullargs();
    pull();
}

sub cmd_push {
    parseopts();
    die if defined $package;
    my $clogp = parsechangelog();
    $package = $clogp->{Source};
    if (@ARGV==0) {
	$suite = $clogp->{Distribution};
	if ($new_package) {
	    local ($package) = $existing_package; # this is a hack
	    canonicalise_suite();
	}
    } else {
	die;
    }
    if (fetch_from_archive()) {
	is_fast_fwd(lrref(), 'HEAD') or die;
    } else {
	die unless $new_package;
    }
    dopush();
}

sub cmd_build {
    # we pass further options and args to git-buildpackage
    die if defined $package;
    my $clogp = parsechangelog();
    $suite = $clogp->{Distribution};
    $package = $clogp->{Source};
    runcmd_ordryrun
	qw(git-buildpackage -us -uc --git-no-sign-tags),
	'--git-builder=dpkg-buildpackage -i\.git/ -I.git',
	"--git-debian-branch=".lbranch(),
	@ARGV;
}

sub parseopts () {
    my $om;
    while (@ARGV) {
	last unless $ARGV[0] =~ m/^-/;
	$_ = shift @ARGV;
	last if m/^--?$/;
	if (m/^--/) {
	    if (m/^--dry-run$/) {
		$dryrun=1;
	    } elsif (m/^--no-sign$/) {
		$sign=0;
	    } elsif (m/^--new$/) {
		$new_package=1;
	    } elsif (m/^--(\w+)=(.*)/s && ($om = $opts_opt_map{$1})) {
		$om->[0] = $2;
	    } elsif (m/^--(\w+):(.*)/s && ($om = $opts_opt_map{$1})) {
		push @$om, $2;
	    } elsif (m/^--existing-package=(.*)/s) {
		$existing_package = $1;
	    } else {
		die "$_ ?";
	    }
	} else {
	    while (m/^-./s) {
		if (s/^-n/-/) {
		    $dryrun=1;
		} elsif (s/^-D/-/) {
		    open DEBUG, ">&STDERR" or die $!;
		    $debug++;
		} elsif (s/^-N/-/) {
		    $new_package=1;
		} elsif (s/^-c(.*=.*)//s) {
		    push @git, '-c', $1;
		} elsif (s/^-C(.*)//s) {
		    $changesfile = $1;
		} elsif (s/^-k(.*)//s) {
		    $keyid=$1;
		} else {
		    die "$_ ?";
		}
	    }
	}
    }
}

parseopts();
print STDERR "DRY RUN ONLY\n" if $dryrun;
die unless @ARGV;
my $cmd = shift @ARGV;

{ no strict qw(refs); &{"cmd_$cmd"}(); }
