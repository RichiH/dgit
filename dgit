#!/usr/bin/perl -w
use strict;

use IO::Handle;
use Data::Dumper;
use LWP::UserAgent;
use Dpkg::Control::Hash;
use File::Path;
use POSIX;

open DEBUG, ">&STDERR" or die $!;

our $pdo = 'http://packages.debian.org/';
#our $mirror = 'http://mirror.relativity.greenend.org.uk/mirror/debian-ftp/';
our $suite = 'sid';
our $package = '2vcard';

our $aliothname = 'iwj@git.debian.org';
our $aliothpath = '/git/dgit-test';
our $alioth_git = 'git+ssh://$aliothname/$aliothpath';
our $alioth_sshtestbodge = [$aliothname,$aliothpath];

our $remotename = 'dgit';

sub mainbranch () { return "$suite"; }
sub uploadbranch () { return "upload/$suite"; }

our $ua;

sub url_get {
    if (!$ua) {
	$ua = LWP::UserAgent->new();
	$ua->env_proxy;
    }
print DEBUG "fetching @_...\n";
    my $r = $ua->get(@_) or die $!;
    die "$_[0]: ".$r->status_line."; failed.\n" unless $r->is_success;
    return $r->decoded_content();
}

our ($dscdata,$dscurl);

sub get_archive_dsc () {
    my $pdourl = "$pdo/source/$suite/$package";
    my $pdodata = url_get($pdourl);
    # FFS.  The Debian archive has no sane way to find what 
    # version is currently the tip in any branch (aka, what
    # is the current version in any suite).
    $pdodata =~ m{
        Download\ \Q$package\E .*
        \<a\ href=\"([^"&]+([^"/]+\.dsc))\"\>\2\</a\>
    }msx
        or die "screenscraping of $pdourl failed :-(\n";
    $dscurl = $1;
print DEBUG Dumper($pdodata, $&, $dscurl);
    $dscdata = url_get($dscurl);
    my $dscfh = new IO::File \$dscdata, '<' or die $!;
print DEBUG Dumper($dscdata, $dscfh);
    my $dscp = Dpkg::Control::Hash->new(allow_pgp=>1);
    $dscp->parse($dscfh, 'dsc') or die "parsing of $dscurl failed\n";
#    my $dscf = $dscp->{'fields'};
my $dscf=$dscp;
print DEBUG Dumper($dscp,$dscf);
    my $fmt = $dscf->{Format};
    die "unsupported format $fmt, sorry\n" unless $fmt eq '1.0';
    return $dscf;
}

sub check_for_git () {
    # returns 0 or 1
    open P, "ssh $alioth_sshtestbodge->[0] '".
	"set -e; cd /git/dgit-test;".
	"if test -d $package.git; then echo 1; else echo 0; fi".
	"' |"
	or die $!;
    $!=0; $?=0;
    my $r = <P>; close P;
    die "$r $! $?" unless $r =~ m/^[01]$/;
    return !!$r;
}

sub runcmd {
    $!=0; $?=0;
    die "$! $?" if system @_;
}

our ($dsc,$dsc_hash,$lastupl_hash);

sub generate_commit_from_dsc () {
    my $ud = '.git/dgit/unpack';
    remove_tree($ud);
    mkpath '.git/dgit';
    mkdir $ud or die $!;
    chdir $ud or die $!;
    my @files;
    foreach (split /\n/, ($dsch->{Checksums-Sha256} || $dsch->{Files})) {
	next unless m/\S/;
	m/^\w+ \d+ (\S+)$/ or die "$_ ?";
	my $f = $1;
	die if $f =~ m#/|^\.|\.dsc$|\.tmp$#;
	push @files, $f;
	link "../../../$f", $f
	    or $!==&ENOENT
	    or die "$f $!";
    }
    runcmd qw(dget --), $dscurl;
    foreach my $f (grep { m/\.tar\.gz$/ } @files) {
	link $f, "../../../$f"
	    or $!==&EEXIST
	    or die "$f $!";
    }
    my (@dirs) = <*/.>;
    die unless @dirs==1;
    $dirs[0] =~ m#^([^/]+)/\.$# or die;
    my $dir = $1;
    chdir $dir or die "$dir $!";
    die if stat '.git';
    die $! unless $!==&ENOENT;
    runcmd qw(git init);
    remove_tree(.git/objects);
    symlink '../../objects','.git/objects' or die $!;
    runcmd qw(git add -Af);
    my $tree = cmdoutput qw(git write-tree);
    chomp $tree or die;
    runcmd qw(sh -ec), 'dpkg-parsechangelog >../changelog.tmp';
    my $clogp = Dpkg::Control::Hash->new();
    $clogp->parse('../changelog.tmp','changelog') or die;
    my $date = cmdoutput qw(date), '+%s %z', qw(-d),$clogp->{Date};
    my $author = $clogp->{Maintainer};
    $author =~ s#,.*##ms;
    my $authline = "$author $date";
    $authline =~ m/^[^<>]+ \<\S+\> \d+ [-+]\d+$/ or die $authline;
    open C, ">../commit.tmp" or die $!;
    print C "tree $tree\n" or die $!;
    print C "parent $lastupl_hash\n" or die $! if defined $lastupl_hash;
    print C <<END or die $!;
author $authline
committer $authline

$clogp->{Changes}
# imported by dgit from the archive
END
    close C or die $!;
    print "synthesised git commit from .dsc $clogp->{Version}\n";
    my $commithash = runcmd qw(git hash-object -w -t commit ../commit.tmp);
    chdir '../../..' or die $!;
    cmdoutput qw(git update-ref -m),"dgit synthesise $clogp->{Version}",
              'DGIT_ARCHIVE', $hash;
    cmdoutput qw(git log -n2), $commithash;
    # ... gives git a chance to complain if our commit is malformed
    my $outputhash = $commithash;
    if (defined $lastupl_hash) {
	chdir $ud or die $!;
	runcmd qw(git reset --hard), $lastupl_hash;
	runcmd qw(sh -ec), 'dpkg-parsechangelog >>../changelogold.tmp';
	my $oldclogp = Dpkg::Control::Hash->new();
	$oldclogp->parse('../changelogold.tmp','previous changelog') or die;
	$vcmp = version_compare_string($oldclogp->{Version}, $clogp->{Version});
	if ($vcmp < 0) {
	    # git upload/ is earlier vsn than archive, use archive
	} elsif ($vcmp >= 0) {
	    print STDERR <<END or die $!;
Version actually in archive:    $clogp->{Version} (older)
Last allegedly pushed/uploaded: $oldclogp->{Version} (newer or same)
Perhaps the upload is stuck in incoming.  Using the version from git.
END
	} else {
	    die "version in archive is same as version in git".
		" to-be-uploaded (upload/) branch but archive".
		" version hash no commit hash?!\n";
        }
	chdir '../../..' or die $!;
    }
    remove_tree($ud);
    return $outputhash;
}

my $lastupl_ref = "refs/remotes/$remotename/upload/$suite";

sub fetch_from_archive () {
    # ensures that $lastupl_ref is what is actually in the archive,
    #  one way or another
    $!=0; $lastupl_hash = `git show-ref --heads $lastupl_ref`;
    die $! if $!;
    die $? unless ($?==0 && chomp $lastupl_hash) 
	or ($?==128 && !length $lastupl_hash);
    my $hash;
    if (defined $dsc_hash) {
	$hash = $dsc_hash;
    } else {
	$hash = generate_commit_from_dsc();
    }
    if ($lastupl_hash) {
	my $mb = cmdoutput qw(git merge-base), $dsc_hash, $lastupl_hash;
	die "not fast forward on last upload branch!"
	    " (archive's version left in DGIT_ARCHIVE)"
	    unless $mb eq $lastupl_hash;
    }
    if ($lastupl_ref ne $hash) {
	cmdoutput qw(git update-ref -m), 'dgit fetch', $lastupl_ref, $hash;
    }
}

#sub combine () {
#    if (
	
#	runcmd qw(git write-tree
	
	
	runcmd qw(mkdir -p '');
#	chdir '.git/dgit/unpack' or die $!;
	
	
#	with_tmpdir($td,{
	    
#    });

#    }

#	open P, "-|", qw(git rev-parse --), $dsc_hash;
	
#}

sub clone () {
    $dsc = get_archive_dsc();
    $dsc_hash = $dsc->{'Vcs-git-master'};
    if (defined $dsc_hash) {
	$dsc_hash =~ m/\w+/ or die "$dsc_hash $?";
	$dsc_hash = $&;
	print "last upload to archive specified git hash\n";
    } else {
	print "last upload to archive has NO git hash\n";
    }
    my $dstdir = "$package";
    if (check_for_git()) {
	print "cloning existing git history\n";
	runcmd qw(git clone --origin),$remotename, qw(-b), $suite, '--',
	    $alioth_git, $dstdir;
	chdir "$dstdir" or die "$dstdir $!";
	record_suite_origin();
	fetch_from_archive();
	runcmd qw(git reset --hard), $lastupl_ref;
    } else {
	die "missing git history even though dsc has hash" if defined $dsc_hash;
	print "starting new git history\n";
	mkdir $dstdir or die "$dstdir $!";
	chdir "$dstdir" or die "$dstdir $!";
	runcmd qw(git init);
	open H, "> .git/refs/HEAD" or die $!;
	print H "ref: refs/heads/$suite\n" or die $!;
	close H or die $!;
	runcmd qw(git remote add), $remotename, $alioth_git;
	record_suite_origin();
	runcmd "git config branch.$suite.remote $remotename";
	runcmd "git config branch.$suite.merge refs/heads/$suite";
	my $newhash = generate_commit_from_dsc();
	runcmd "git reset --hard", $newhash;
    }
}

sub fetch () {
    
}
    
print Dumper(get_archive_dsc());
