.TH dgit 1 "" "Debian Project" "dgit"
.SH NAME
dgit \- git integration with the Debian archive
.
.SH SYNOPSIS
.B dgit
[\fIdgit\-opts\fP] \fBclone\fP [\fIdgit\-opts\fP]
\fIpackage\fP [\fIsuite\fP] [\fB./\fP\fIdir|\fB/\fP\fIdir]
.br
.B dgit
[\fIdgit\-opts\fP] \fBfetch\fP|\fBpull\fP [\fIdgit\-opts\fP]
[\fIsuite\fP]
.br
.B dgit
[\fIdgit\-opts\fP] \fBbuild\fP
[\fIgit\-buildpackage\-opts\fP|\fIdpkg\-buildpackage\-opts\fp]
.br
.B dgit
[\fIdgit\-opts\fP] \fBpush\fP [\fIdgit\-opts\fP]
[\fIsuite\fP]
.SH DESCRIPTION
.B dgit
treats the Debian archive as a version control system, and
bidirectionally gateways between the archive and git.  The git view of
the package can contain the usual upstream git history, and will be
augmented by commits representing uploads done by other developers not
using dgit.  This git history is stored in a canonical location known
as
.B dgit-repos
which lives outside the Debian archive (currently, on Alioth).

.B dgit clone
and
.B dgit fetch
consult the archive and dgit-repos and fetch and/or construct the
git view of the history.  With clone, the destination directory (by
default, the package name in the current directory) will be created,
and the new directory's `origin' remote will be set up to point to
the package's dgit-repos tree.

.B dgit build
runs
.B git-buildpackage
with some suitable options.  Options after
.B build
will be passed on to git-buildpackage.  It is not necessary to
use dgit build; it is OK to use any approach which ensures that
the generated source package corresponds to the relevant git commit.
Tagging and signing should be left to dgit push.

.B dgit push
does an `upload', pushing the current HEAD to the archive (as a source
package) and to dgit-repos (as git commits).  This also involves
making a signed git tag, and signing the files to be uploaded to the
archive.  dgit push does a
.BR "debian/rules clean" .
.SH WORKFLOW - SIMPLE
It is always possible with dgit to clone or fetch a package, make
changes in git (using git-commit) on the suite branch
.RB ( "git checkout dgit/" \fIsuite\fR)
and then dgit push.  You can use whatever gitish techniques you like
to construct the commit to push; the only requirement is that it is a
descendant of the state of the archive, as provided by dgit in the
remote tracking branch
.BR remotes/dgit/ \fIsuite\fR.

If you are lucky the other uploaders have also used dgit and
integrated the other relevant git history; if not you can fetch it
into your tree and cherry-pick etc. as you wish.
.SH WORKFLOW - INTEGRATING BETWEEN DGIT AND OTHER GIT HISTORY
If you are the maintainer of a package dealing with uploads made
without dgit, you will probably want to merge the synthetic commits
(made by dgit to represent the uploads) into your git history.
Normally you can just merge the dgit branch into your own master, or
indeed if you do your work on the dgit local suite branch
.BI dgit/ suite
you can just use dgit pull.

However the first time dgit is used it will generate a new origin
commit from the archive which won't be linked into the rest of your
git history.  You will need to merge this.

If last upload was in fact made with git, you should usually proceed
as follows: identify the commit which was actually used to build the
package.  (Hopefully you have a tag for this.)  Check out the dgit
branch
.RB ( "git checkout dgit/" \fIsuite\fR)
and merge that other commit
.RB ( "git merge debian/" \fIversion\fR).
Hopefully this merge will be trivial because the two trees should
be the same.  The resulting branch head can be merged into your
working branches
.RB ( "git checkout master && git merge dgit/" \fIsuite\fR).

If last upload was not made with git, a different approach is required
to start using dgit.  First, do
.B dgit fetch
(or clone) obtain a git history representation of what's in the
archive and record it in the
.BI remotes/dgit/ suite
tracking branch.  Then construct somehow, using your other git history
plus appropriate diffs and cherry picks from the dgit remote tracking
branch, a git commit whose tree corresponds to the tree to use for the
next upload.  If that commit-to-be-uploaded is not a descendant of the
dig remote tracking branch, check it out and say
.BR "git merge -s ours remotes/dgit/" \fIsuite\fR;
that tells git that we are deliberately throwing away any differences
between what's in the archive and what you intend to upload.
Then run
.BR "dgit push"
to actually upload the result.
.SH MODEL
You may use any suitable git workflow with dgit, provided you
satisfy dgit's requirements:

dgit maintains a pseudo-remote called
.BR dgit ,
with one branch per suite.  This remote cannot be used with
plain git.

The
.B dgit-repos
repository for each package contains one ref per suite named
\fBrefs/dgit/\fR\fIsuite\fR.  These should be pushed to only by
dgit.  They are fast forwarding.  Each push on this branch
corresponds to an upload (or attempted upload).

However, it is perfectly fine to have other branches in dgit-repos;
normally the dgit-repos repo for the package will be accessible via
the remote name `origin'.

dgit push can operate on any commit which is a descendant of the
current dgit/suite tip in dgit-repos.

Uploads made by dgit contain an additional field
.B Vcs-Dgit-Master
in the source package .dsc.  (This is added by dgit push.)
This specifies a commit (an ancestor of the dgit/suite
branch) whose tree is identical to the unpacked source upload.

Uploads not made by dgit are represented in git by commits which are
synthesised by dgit.  The tree of each such commit corresponds to the
unpacked source; there is an origin commit with the contents, and a
psuedo-merge from last known upload - that is, from the contents of
the dgit/suite branch.

dgit expects repos that it works with to have a
.B dgit
remote.  This refers to the well-known dgit-repos location
(currently, the dgit-repos project on Alioth).  dgit fetch updates
the remote tracking branch for dgit/suite.

dgit does not (currently) represent the orig tarball(s) in git; nor
does it represent the patch statck of a `3.0 (quilt)' package.  The
orig tarballs are downloaded and kept in the parent directory, as with
a traditional (non-gitish) dpkg-source workflow.

To a user looking at the archive, changes pushed using dgit look like
changes made in an NMU: in a `3.0 (quilt)' package the delta from the
previous upload is recorded in a new patch constructed by dpkg-source.
.SH PACKAGE SOURCE FORMATS
If you are not the maintainer, you do not need to worry about the
source format of the package.  You can just make changes as you like
in git.  If the package is a `3.0 (quilt)' package, the patch stack
will usually not be represented in the git history.

If you are the maintainer of a non-native package, you currently have
two sensible options:

Firstly, you can regard your git history as primary, and the archive
as an export format.  For example, you could maintain topic branches
in git and a fast-forwarding release branch; or you could do your work
directly in a merging way on the
.BI dgit/ suite
branches.  If you do this you should probably use a `1.0' format
source package.  In the archive, the delta between upstream will be
represented in the single Debian patch.

Secondly, you can regard your quiltish patch stack in the archive as
primary.  You will have to use other tools besides dgit to import and
export this patch stack.  See also the BUGS section.
.SH OPTIONS
.TP
.BR --dry-run | -n
Go through the motions, fetching all information needed, but do not
actually update the output(s).  For push, dgit does
the required checks and leaves the new .dsc in a temporary file,
but does not sign, tag, push or upload.
.TP
.BI -k keyid
Use
.I keyid
for signing the tag and the upload.
.TP
.BR --no-sign
does not sign tags or uploads (meaningful only with push).
.TP
.TP
.BI -p package
Specifies that we should process source package
.I package
rather than looking in debian/control or debian/changelog.
Valid with dgit fetch and dgit pull, only.
.TP
.BR -N | --new
The package may be new in this suite.  Without this, dgit will
refuse to push.
.TP
.BI -D
Prints debugging information to stderr.  Repeating the option produces
more output (currently, up to -DD is meaningfully different).
.TP
.BI -c name = value
Specifies a git configuration option.  dgit itself is also controlled
by git configuration options.
.TP
.RI \fB--dget=\fR program |\fB--dput=\fR program |\fB--debsign=\fR program
Specifies alternative programs to use instead of dget, dput
or debsign.
.TP
.RI \fB--dget:\fR option |\fB--dput:\fR option |\fB--debsign:\fR option
Specifies a single additional option to pass to dget, dput or
debsign.  Use repeatedly if multiple additional options are required.
.TP
.BI -C changesfile
Specifies the .changes file which is to be uploaded.  By default
dgit push looks for single .changes file in the parent directory whose
filename suggests it is for the right package and version.
.TP
.BI --existing-package= package
dgit push needs to canonicalise the suite name.  But currently
there is no way to ask the archive to do this without knowing the
name of an existing package.  Without --new we can just use the
package we are trying to push.  But with --new that will not work, so
we guess that
.TP
.BI --clean-command= "cmd arg arg"
dgit push needs to clean the tree to make sure the 
.SH CONFIGURATION
dgit looks at the following git config keys to control its behaviour.
You may set them with git-config (either in system-global or per-tree
configuration), or provide
.BI -c key = value
on the dgit command line.
.TP
.BI dgit-suite. suite .distro
.TP
.BI dgit.default.distro
.TP
.BI dgit.default.username
.TP
.BI dgit-distro. distro .git-url
.TP
.BI dgit-distro. distro .git-host
.TP
.BI dgit-distro. distro .git-proto
.TP
.BI dgit-distro. distro .git-path
.TP
.BI dgit-distro. distro .git-check
.TP
.BI dgit-distro. distro .git-create
.TP
.BI dgit-distro. distro .upload-host
.TP
.BI dgit-distro. distro .mirror
.TP
.BI dgit-distro. distro .archive-query
.TP
.BI dgit-distro. distro .archive-query-default-component
.TP
.BI dgit-distro. distro .ssh
.TP
.BR dgit.default. *
for each
.BR dgit-distro. \fIdistro\fR . *
.SH BUGS
We should be using some kind of vhost/vpath setup for the git repos on
alioth, so that they can be moved later if and when this turns out to
be a good idea.

Debian Policy needs to be updated to describe the new Vcs-Dgit-Master
field (and to specify that it is an RC bug for that field to refer
to an unavailable commit).

The method of canonicalising suite names is bizarre.  See the
.B --existing-package
option for one of the implication.s

dgit push should perhaps do `git push origin', or something similar,
by default.

The mechanism for checking for and creating per-package repos on
alioth is a hideous bodge.  One consequence is that dgit currently
only works for people with push access.

Debian Maintainers are currently not able to push, as there is not
currently any mechanism for determining and honouring the archive's
ideas about access control.  Currently only DDs can push.

dgit's representation of format `3.0 (quilt)' source packages does not
represent the patch stack.  Currently the patch series representation
cannot round trip through the archive.  Ideally dgit would represent a
quilty package with an origin commit of some kind followed by the
patch stack as a series of commits followed by a pseudo-merge (to make
the branch fast-forwarding).  This would also mean a new `dgit
rebase-prep' command or some such to turn such a fast-forwarding
branch back into a rebasing patch stack, and a `force' option to dgit
push (perhaps enabled automatically by a note left by rebase-prep)
which will make the required pseudo-merge.

If the dgit push fails halfway through, it should be restartable and
idempotent.  However this is not true for the git tag operation.
Also, it would be good to check that the proposed signing key is
available before starting work.

dgit's handling of .orig.tar.gz is not very sophisticated.  Ideally
the .orig.tar.gz could be transported via the git repo as git tags.
Doing this is made more complicated by the possibility of a `3.0
(quilt)' package with multiple .orig tarballs.

The error messages are often unhelpfully terse and tend to refer to
line numbers in dgit.

The option parser requires values to be cuddled to the option name.

dgit assumes knowledge of the archive layout.  There appears to be no
sane way to find the path in the archive pool of the .dsc for a
particular suite.  I'm assured that the archive layout is a
`well known algorithm' by now.

--dry-run often does not work with fetch, even though this is a
logically plausible request.  (It fails, instead.)
